{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/await-lock@2.2.2/node_modules/await-lock/src/AwaitLock.ts"],
  "sourcesContent": ["/**\n * A mutex lock for coordination across async functions\n */\nexport default class AwaitLock {\n  #acquired: boolean = false;\n  #waitingResolvers: Set<() => void> = new Set();\n\n  /**\n   * Whether the lock is currently acquired or not. Accessing this property does not affect the\n   * status of the lock.\n   */\n  get acquired(): boolean {\n    return this.#acquired;\n  }\n\n  /**\n   * Acquires the lock, waiting if necessary for it to become free if it is already locked. The\n   * returned promise is fulfilled once the lock is acquired.\n   *\n   * A timeout (in milliseconds) may be optionally provided. If the lock cannot be acquired before\n   * the timeout elapses, the returned promise is rejected with an error. The behavior of invalid\n   * timeout values depends on how `setTimeout` handles those values.\n   *\n   * After acquiring the lock, you **must** call `release` when you are done with it.\n   */\n  acquireAsync({ timeout }: { timeout?: number } = {}): Promise<void> {\n    if (!this.#acquired) {\n      this.#acquired = true;\n      return Promise.resolve();\n    }\n\n    if (timeout == null) {\n      return new Promise((resolve) => {\n        this.#waitingResolvers.add(resolve);\n      });\n    }\n\n    let resolver: () => void;\n    let timer: ReturnType<typeof setTimeout>;\n\n    return Promise.race<void>([\n      new Promise((resolve) => {\n        resolver = () => {\n          clearTimeout(timer);\n          resolve();\n        };\n        this.#waitingResolvers.add(resolver);\n      }),\n      new Promise<void>((_, reject) => {\n        timer = setTimeout(() => {\n          this.#waitingResolvers.delete(resolver);\n          reject(new Error(`Timed out waiting for lock`));\n        }, timeout);\n      }),\n    ]);\n  }\n\n  /**\n   * Acquires the lock if it is free and otherwise returns immediately without waiting. Returns\n   * `true` if the lock was free and is now acquired, and `false` otherwise.\n   *\n   * This method differs from calling `acquireAsync` with a zero-millisecond timeout in that it runs\n   * synchronously without waiting for the JavaScript task queue.\n   */\n  tryAcquire(): boolean {\n    if (!this.#acquired) {\n      this.#acquired = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Releases the lock and gives it to the next waiting acquirer, if there is one. Each acquirer\n   * must release the lock exactly once.\n   */\n  release(): void {\n    if (!this.#acquired) {\n      throw new Error(`Cannot release an unacquired lock`);\n    }\n\n    if (this.#waitingResolvers.size > 0) {\n      // Sets preserve insertion order like a queue\n      const [resolve] = this.#waitingResolvers;\n      this.#waitingResolvers.delete(resolve);\n      resolve();\n    } else {\n      this.#acquired = false;\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAGA,QAAqB,YAArB,MAA8B;MAA9B,cAAA;AACE,4BAAA,IAAA,MAAqB,KAAK;AAC1B,oCAAA,IAAA,MAAqC,oBAAI,IAAG,CAAE;MAsFhD;;;;;MAhFE,IAAI,WAAQ;AACV,eAAO,uBAAA,MAAI,qBAAA,GAAA;MACb;;;;;;;;;;;MAYA,aAAa,EAAE,QAAO,IAA2B,CAAA,GAAE;AACjD,YAAI,CAAC,uBAAA,MAAI,qBAAA,GAAA,GAAY;AACnB,iCAAA,MAAI,qBAAa,MAAI,GAAA;AACrB,iBAAO,QAAQ,QAAO;;AAGxB,YAAI,WAAW,MAAM;AACnB,iBAAO,IAAI,QAAQ,CAAC,YAAW;AAC7B,mCAAA,MAAI,6BAAA,GAAA,EAAmB,IAAI,OAAO;UACpC,CAAC;;AAGH,YAAI;AACJ,YAAI;AAEJ,eAAO,QAAQ,KAAW;UACxB,IAAI,QAAQ,CAAC,YAAW;AACtB,uBAAW,MAAK;AACd,2BAAa,KAAK;AAClB,sBAAO;YACT;AACA,mCAAA,MAAI,6BAAA,GAAA,EAAmB,IAAI,QAAQ;UACrC,CAAC;UACD,IAAI,QAAc,CAAC,GAAG,WAAU;AAC9B,oBAAQ,WAAW,MAAK;AACtB,qCAAA,MAAI,6BAAA,GAAA,EAAmB,OAAO,QAAQ;AACtC,qBAAO,IAAI,MAAM,4BAA4B,CAAC;YAChD,GAAG,OAAO;UACZ,CAAC;SACF;MACH;;;;;;;;MASA,aAAU;AACR,YAAI,CAAC,uBAAA,MAAI,qBAAA,GAAA,GAAY;AACnB,iCAAA,MAAI,qBAAa,MAAI,GAAA;AACrB,iBAAO;;AAGT,eAAO;MACT;;;;;MAMA,UAAO;AACL,YAAI,CAAC,uBAAA,MAAI,qBAAA,GAAA,GAAY;AACnB,gBAAM,IAAI,MAAM,mCAAmC;;AAGrD,YAAI,uBAAA,MAAI,6BAAA,GAAA,EAAmB,OAAO,GAAG;AAEnC,gBAAM,CAAC,OAAO,IAAI,uBAAA,MAAI,6BAAA,GAAA;AACtB,iCAAA,MAAI,6BAAA,GAAA,EAAmB,OAAO,OAAO;AACrC,kBAAO;eACF;AACL,iCAAA,MAAI,qBAAa,OAAK,GAAA;;MAE1B;;AAvFF,YAAA,UAAA;;;;",
  "names": []
}
